/*
 * App Store Connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.2
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AppsApiService AppsApi service
type AppsApiService service

type ApiAppsAppInfosGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsAppInfos *[]string
	fieldsAppCategories *[]string
	fieldsAppInfoLocalizations *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
}

func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsAppInfosGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppInfosGetToManyRelatedRequest {
	r.limit = &limit
	return r
}
func (r ApiAppsAppInfosGetToManyRelatedRequest) Include(include []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppInfosGetToManyRelatedRequest) Execute() (AppInfosResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsAppInfosGetToManyRelatedExecute(r)
}

/*
 * AppsAppInfosGetToManyRelated Method for AppsAppInfosGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsAppInfosGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsAppInfosGetToManyRelated(ctx _context.Context, id string) ApiAppsAppInfosGetToManyRelatedRequest {
	return ApiAppsAppInfosGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppInfosResponse
 */
func (a *AppsApiService) AppsAppInfosGetToManyRelatedExecute(r ApiAppsAppInfosGetToManyRelatedRequest) (AppInfosResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppInfosResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppInfosGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppInfos != nil {
		localVarQueryParams.Add("fields[appInfos]", parameterToString(*r.fieldsAppInfos, "csv"))
	}
	if r.fieldsAppCategories != nil {
		localVarQueryParams.Add("fields[appCategories]", parameterToString(*r.fieldsAppCategories, "csv"))
	}
	if r.fieldsAppInfoLocalizations != nil {
		localVarQueryParams.Add("fields[appInfoLocalizations]", parameterToString(*r.fieldsAppInfoLocalizations, "csv"))
	}
	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppStoreVersionsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	filterAppStoreState *[]string
	filterPlatform *[]string
	filterVersionString *[]string
	filterId *[]string
	fieldsIdfaDeclarations *[]string
	fieldsAppStoreVersionLocalizations *[]string
	fieldsRoutingAppCoverages *[]string
	fieldsAppStoreVersionPhasedReleases *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppStoreReviewDetails *[]string
	fieldsAppStoreVersions *[]string
	fieldsBuilds *[]string
	fieldsAppStoreVersionSubmissions *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
}

func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterAppStoreState(filterAppStoreState []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterAppStoreState = &filterAppStoreState
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsIdfaDeclarations(fieldsIdfaDeclarations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsIdfaDeclarations = &fieldsIdfaDeclarations
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Include(include []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Execute() (AppStoreVersionsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsAppStoreVersionsGetToManyRelatedExecute(r)
}

/*
 * AppsAppStoreVersionsGetToManyRelated Method for AppsAppStoreVersionsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsAppStoreVersionsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelated(ctx _context.Context, id string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	return ApiAppsAppStoreVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionsResponse
 */
func (a *AppsApiService) AppsAppStoreVersionsGetToManyRelatedExecute(r ApiAppsAppStoreVersionsGetToManyRelatedRequest) (AppStoreVersionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAppStoreVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appStoreVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterAppStoreState != nil {
		localVarQueryParams.Add("filter[appStoreState]", parameterToString(*r.filterAppStoreState, "csv"))
	}
	if r.filterPlatform != nil {
		localVarQueryParams.Add("filter[platform]", parameterToString(*r.filterPlatform, "csv"))
	}
	if r.filterVersionString != nil {
		localVarQueryParams.Add("filter[versionString]", parameterToString(*r.filterVersionString, "csv"))
	}
	if r.filterId != nil {
		localVarQueryParams.Add("filter[id]", parameterToString(*r.filterId, "csv"))
	}
	if r.fieldsIdfaDeclarations != nil {
		localVarQueryParams.Add("fields[idfaDeclarations]", parameterToString(*r.fieldsIdfaDeclarations, "csv"))
	}
	if r.fieldsAppStoreVersionLocalizations != nil {
		localVarQueryParams.Add("fields[appStoreVersionLocalizations]", parameterToString(*r.fieldsAppStoreVersionLocalizations, "csv"))
	}
	if r.fieldsRoutingAppCoverages != nil {
		localVarQueryParams.Add("fields[routingAppCoverages]", parameterToString(*r.fieldsRoutingAppCoverages, "csv"))
	}
	if r.fieldsAppStoreVersionPhasedReleases != nil {
		localVarQueryParams.Add("fields[appStoreVersionPhasedReleases]", parameterToString(*r.fieldsAppStoreVersionPhasedReleases, "csv"))
	}
	if r.fieldsAgeRatingDeclarations != nil {
		localVarQueryParams.Add("fields[ageRatingDeclarations]", parameterToString(*r.fieldsAgeRatingDeclarations, "csv"))
	}
	if r.fieldsAppStoreReviewDetails != nil {
		localVarQueryParams.Add("fields[appStoreReviewDetails]", parameterToString(*r.fieldsAppStoreReviewDetails, "csv"))
	}
	if r.fieldsAppStoreVersions != nil {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(*r.fieldsAppStoreVersions, "csv"))
	}
	if r.fieldsBuilds != nil {
		localVarQueryParams.Add("fields[builds]", parameterToString(*r.fieldsBuilds, "csv"))
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		localVarQueryParams.Add("fields[appStoreVersionSubmissions]", parameterToString(*r.fieldsAppStoreVersionSubmissions, "csv"))
	}
	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAvailableTerritoriesGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsTerritories *[]string
	limit *int32
}

func (r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}
func (r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) Limit(limit int32) ApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) Execute() (TerritoriesResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsAvailableTerritoriesGetToManyRelatedExecute(r)
}

/*
 * AppsAvailableTerritoriesGetToManyRelated Method for AppsAvailableTerritoriesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsAvailableTerritoriesGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelated(ctx _context.Context, id string) ApiAppsAvailableTerritoriesGetToManyRelatedRequest {
	return ApiAppsAvailableTerritoriesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return TerritoriesResponse
 */
func (a *AppsApiService) AppsAvailableTerritoriesGetToManyRelatedExecute(r ApiAppsAvailableTerritoriesGetToManyRelatedRequest) (TerritoriesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TerritoriesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsAvailableTerritoriesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/availableTerritories"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsTerritories != nil {
		localVarQueryParams.Add("fields[territories]", parameterToString(*r.fieldsTerritories, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaAppLocalizationsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaAppLocalizations *[]string
	limit *int32
}

func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}
func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Execute() (BetaAppLocalizationsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsBetaAppLocalizationsGetToManyRelatedExecute(r)
}

/*
 * AppsBetaAppLocalizationsGetToManyRelated Method for AppsBetaAppLocalizationsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsBetaAppLocalizationsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelated(ctx _context.Context, id string) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	return ApiAppsBetaAppLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BetaAppLocalizationsResponse
 */
func (a *AppsApiService) AppsBetaAppLocalizationsGetToManyRelatedExecute(r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) (BetaAppLocalizationsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaAppLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaAppLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsBetaAppLocalizations != nil {
		localVarQueryParams.Add("fields[betaAppLocalizations]", parameterToString(*r.fieldsBetaAppLocalizations, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaAppReviewDetailGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaAppReviewDetails *[]string
}

func (r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

func (r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) Execute() (BetaAppReviewDetailResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsBetaAppReviewDetailGetToOneRelatedExecute(r)
}

/*
 * AppsBetaAppReviewDetailGetToOneRelated Method for AppsBetaAppReviewDetailGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsBetaAppReviewDetailGetToOneRelatedRequest
 */
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelated(ctx _context.Context, id string) ApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	return ApiAppsBetaAppReviewDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BetaAppReviewDetailResponse
 */
func (a *AppsApiService) AppsBetaAppReviewDetailGetToOneRelatedExecute(r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) (BetaAppReviewDetailResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaAppReviewDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaAppReviewDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppReviewDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsBetaAppReviewDetails != nil {
		localVarQueryParams.Add("fields[betaAppReviewDetails]", parameterToString(*r.fieldsBetaAppReviewDetails, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaGroupsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaGroups *[]string
	limit *int32
}

func (r ApiAppsBetaGroupsGetToManyRelatedRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsBetaGroupsGetToManyRelatedRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}
func (r ApiAppsBetaGroupsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBetaGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaGroupsGetToManyRelatedRequest) Execute() (BetaGroupsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsBetaGroupsGetToManyRelatedExecute(r)
}

/*
 * AppsBetaGroupsGetToManyRelated Method for AppsBetaGroupsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsBetaGroupsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsBetaGroupsGetToManyRelated(ctx _context.Context, id string) ApiAppsBetaGroupsGetToManyRelatedRequest {
	return ApiAppsBetaGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BetaGroupsResponse
 */
func (a *AppsApiService) AppsBetaGroupsGetToManyRelatedExecute(r ApiAppsBetaGroupsGetToManyRelatedRequest) (BetaGroupsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsBetaGroups != nil {
		localVarQueryParams.Add("fields[betaGroups]", parameterToString(*r.fieldsBetaGroups, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaLicenseAgreementGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsBetaLicenseAgreements *[]string
}

func (r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

func (r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) Execute() (BetaLicenseAgreementResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsBetaLicenseAgreementGetToOneRelatedExecute(r)
}

/*
 * AppsBetaLicenseAgreementGetToOneRelated Method for AppsBetaLicenseAgreementGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsBetaLicenseAgreementGetToOneRelatedRequest
 */
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelated(ctx _context.Context, id string) ApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	return ApiAppsBetaLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BetaLicenseAgreementResponse
 */
func (a *AppsApiService) AppsBetaLicenseAgreementGetToOneRelatedExecute(r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) (BetaLicenseAgreementResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BetaLicenseAgreementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsBetaLicenseAgreements != nil {
		localVarQueryParams.Add("fields[betaLicenseAgreements]", parameterToString(*r.fieldsBetaLicenseAgreements, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaTestersDeleteToManyRelationshipRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	appBetaTestersLinkagesRequest *AppBetaTestersLinkagesRequest
}

func (r ApiAppsBetaTestersDeleteToManyRelationshipRequest) AppBetaTestersLinkagesRequest(appBetaTestersLinkagesRequest AppBetaTestersLinkagesRequest) ApiAppsBetaTestersDeleteToManyRelationshipRequest {
	r.appBetaTestersLinkagesRequest = &appBetaTestersLinkagesRequest
	return r
}

func (r ApiAppsBetaTestersDeleteToManyRelationshipRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AppsBetaTestersDeleteToManyRelationshipExecute(r)
}

/*
 * AppsBetaTestersDeleteToManyRelationship Method for AppsBetaTestersDeleteToManyRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsBetaTestersDeleteToManyRelationshipRequest
 */
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationship(ctx _context.Context, id string) ApiAppsBetaTestersDeleteToManyRelationshipRequest {
	return ApiAppsBetaTestersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AppsApiService) AppsBetaTestersDeleteToManyRelationshipExecute(r ApiAppsBetaTestersDeleteToManyRelationshipRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBetaTestersDeleteToManyRelationship")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/betaTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appBetaTestersLinkagesRequest == nil {
		return nil, reportError("appBetaTestersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appBetaTestersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppsBuildsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsBuilds *[]string
	limit *int32
}

func (r ApiAppsBuildsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsBuildsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}
func (r ApiAppsBuildsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBuildsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBuildsGetToManyRelatedRequest) Execute() (BuildsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsBuildsGetToManyRelatedExecute(r)
}

/*
 * AppsBuildsGetToManyRelated Method for AppsBuildsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsBuildsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsBuildsGetToManyRelated(ctx _context.Context, id string) ApiAppsBuildsGetToManyRelatedRequest {
	return ApiAppsBuildsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BuildsResponse
 */
func (a *AppsApiService) AppsBuildsGetToManyRelatedExecute(r ApiAppsBuildsGetToManyRelatedRequest) (BuildsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsBuildsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsBuilds != nil {
		localVarQueryParams.Add("fields[builds]", parameterToString(*r.fieldsBuilds, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsEndUserLicenseAgreements *[]string
}

func (r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

func (r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) Execute() (EndUserLicenseAgreementResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsEndUserLicenseAgreementGetToOneRelatedExecute(r)
}

/*
 * AppsEndUserLicenseAgreementGetToOneRelated Method for AppsEndUserLicenseAgreementGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest
 */
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelated(ctx _context.Context, id string) ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	return ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return EndUserLicenseAgreementResponse
 */
func (a *AppsApiService) AppsEndUserLicenseAgreementGetToOneRelatedExecute(r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) (EndUserLicenseAgreementResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EndUserLicenseAgreementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsEndUserLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/endUserLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsEndUserLicenseAgreements != nil {
		localVarQueryParams.Add("fields[endUserLicenseAgreements]", parameterToString(*r.fieldsEndUserLicenseAgreements, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	filterPlatform *[]string
	filterVersionString *[]string
	filterId *[]string
	sort *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
}

func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Sort(sort []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Include(include []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Execute() (GameCenterEnabledVersionsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r)
}

/*
 * AppsGameCenterEnabledVersionsGetToManyRelated Method for AppsGameCenterEnabledVersionsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelated(ctx _context.Context, id string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	return ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return GameCenterEnabledVersionsResponse
 */
func (a *AppsApiService) AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) (GameCenterEnabledVersionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GameCenterEnabledVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGameCenterEnabledVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/gameCenterEnabledVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterPlatform != nil {
		localVarQueryParams.Add("filter[platform]", parameterToString(*r.filterPlatform, "csv"))
	}
	if r.filterVersionString != nil {
		localVarQueryParams.Add("filter[versionString]", parameterToString(*r.filterVersionString, "csv"))
	}
	if r.filterId != nil {
		localVarQueryParams.Add("filter[id]", parameterToString(*r.filterId, "csv"))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, "csv"))
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		localVarQueryParams.Add("fields[gameCenterEnabledVersions]", parameterToString(*r.fieldsGameCenterEnabledVersions, "csv"))
	}
	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGetCollectionRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	filterAppStoreVersionsAppStoreState *[]string
	filterAppStoreVersionsPlatform *[]string
	filterBundleId *[]string
	filterName *[]string
	filterSku *[]string
	filterAppStoreVersions *[]string
	filterId *[]string
	existsGameCenterEnabledVersions *[]string
	sort *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
	fieldsBetaGroups *[]string
	fieldsPerfPowerMetrics *[]string
	fieldsAppInfos *[]string
	fieldsAppPreOrders *[]string
	fieldsPreReleaseVersions *[]string
	fieldsAppPrices *[]string
	fieldsInAppPurchases *[]string
	fieldsBetaAppReviewDetails *[]string
	fieldsTerritories *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsAppStoreVersions *[]string
	fieldsBuilds *[]string
	fieldsBetaAppLocalizations *[]string
	fieldsBetaLicenseAgreements *[]string
	fieldsEndUserLicenseAgreements *[]string
	limitAppInfos *int32
	limitAppStoreVersions *int32
	limitAvailableTerritories *int32
	limitBetaAppLocalizations *int32
	limitBetaGroups *int32
	limitBuilds *int32
	limitGameCenterEnabledVersions *int32
	limitInAppPurchases *int32
	limitPreReleaseVersions *int32
	limitPrices *int32
}

func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsAppStoreState(filterAppStoreVersionsAppStoreState []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsAppStoreState = &filterAppStoreVersionsAppStoreState
	return r
}
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsPlatform(filterAppStoreVersionsPlatform []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsPlatform = &filterAppStoreVersionsPlatform
	return r
}
func (r ApiAppsGetCollectionRequest) FilterBundleId(filterBundleId []string) ApiAppsGetCollectionRequest {
	r.filterBundleId = &filterBundleId
	return r
}
func (r ApiAppsGetCollectionRequest) FilterName(filterName []string) ApiAppsGetCollectionRequest {
	r.filterName = &filterName
	return r
}
func (r ApiAppsGetCollectionRequest) FilterSku(filterSku []string) ApiAppsGetCollectionRequest {
	r.filterSku = &filterSku
	return r
}
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersions(filterAppStoreVersions []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersions = &filterAppStoreVersions
	return r
}
func (r ApiAppsGetCollectionRequest) FilterId(filterId []string) ApiAppsGetCollectionRequest {
	r.filterId = &filterId
	return r
}
func (r ApiAppsGetCollectionRequest) ExistsGameCenterEnabledVersions(existsGameCenterEnabledVersions []string) ApiAppsGetCollectionRequest {
	r.existsGameCenterEnabledVersions = &existsGameCenterEnabledVersions
	return r
}
func (r ApiAppsGetCollectionRequest) Sort(sort []string) ApiAppsGetCollectionRequest {
	r.sort = &sort
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsApps(fieldsApps []string) ApiAppsGetCollectionRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsGetCollectionRequest) Limit(limit int32) ApiAppsGetCollectionRequest {
	r.limit = &limit
	return r
}
func (r ApiAppsGetCollectionRequest) Include(include []string) ApiAppsGetCollectionRequest {
	r.include = &include
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsPerfPowerMetrics(fieldsPerfPowerMetrics []string) ApiAppsGetCollectionRequest {
	r.fieldsPerfPowerMetrics = &fieldsPerfPowerMetrics
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsGetCollectionRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsGetCollectionRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsGetCollectionRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsGetCollectionRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}
func (r ApiAppsGetCollectionRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsGetCollectionRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}
func (r ApiAppsGetCollectionRequest) LimitAppInfos(limitAppInfos int32) ApiAppsGetCollectionRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}
func (r ApiAppsGetCollectionRequest) LimitAppStoreVersions(limitAppStoreVersions int32) ApiAppsGetCollectionRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}
func (r ApiAppsGetCollectionRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiAppsGetCollectionRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}
func (r ApiAppsGetCollectionRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) ApiAppsGetCollectionRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}
func (r ApiAppsGetCollectionRequest) LimitBetaGroups(limitBetaGroups int32) ApiAppsGetCollectionRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}
func (r ApiAppsGetCollectionRequest) LimitBuilds(limitBuilds int32) ApiAppsGetCollectionRequest {
	r.limitBuilds = &limitBuilds
	return r
}
func (r ApiAppsGetCollectionRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) ApiAppsGetCollectionRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}
func (r ApiAppsGetCollectionRequest) LimitInAppPurchases(limitInAppPurchases int32) ApiAppsGetCollectionRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}
func (r ApiAppsGetCollectionRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) ApiAppsGetCollectionRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}
func (r ApiAppsGetCollectionRequest) LimitPrices(limitPrices int32) ApiAppsGetCollectionRequest {
	r.limitPrices = &limitPrices
	return r
}

func (r ApiAppsGetCollectionRequest) Execute() (AppsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsGetCollectionExecute(r)
}

/*
 * AppsGetCollection Method for AppsGetCollection
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAppsGetCollectionRequest
 */
func (a *AppsApiService) AppsGetCollection(ctx _context.Context) ApiAppsGetCollectionRequest {
	return ApiAppsGetCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AppsResponse
 */
func (a *AppsApiService) AppsGetCollectionExecute(r ApiAppsGetCollectionRequest) (AppsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGetCollection")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterAppStoreVersionsAppStoreState != nil {
		localVarQueryParams.Add("filter[appStoreVersions.appStoreState]", parameterToString(*r.filterAppStoreVersionsAppStoreState, "csv"))
	}
	if r.filterAppStoreVersionsPlatform != nil {
		localVarQueryParams.Add("filter[appStoreVersions.platform]", parameterToString(*r.filterAppStoreVersionsPlatform, "csv"))
	}
	if r.filterBundleId != nil {
		localVarQueryParams.Add("filter[bundleId]", parameterToString(*r.filterBundleId, "csv"))
	}
	if r.filterName != nil {
		localVarQueryParams.Add("filter[name]", parameterToString(*r.filterName, "csv"))
	}
	if r.filterSku != nil {
		localVarQueryParams.Add("filter[sku]", parameterToString(*r.filterSku, "csv"))
	}
	if r.filterAppStoreVersions != nil {
		localVarQueryParams.Add("filter[appStoreVersions]", parameterToString(*r.filterAppStoreVersions, "csv"))
	}
	if r.filterId != nil {
		localVarQueryParams.Add("filter[id]", parameterToString(*r.filterId, "csv"))
	}
	if r.existsGameCenterEnabledVersions != nil {
		localVarQueryParams.Add("exists[gameCenterEnabledVersions]", parameterToString(*r.existsGameCenterEnabledVersions, "csv"))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, "csv"))
	}
	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsBetaGroups != nil {
		localVarQueryParams.Add("fields[betaGroups]", parameterToString(*r.fieldsBetaGroups, "csv"))
	}
	if r.fieldsPerfPowerMetrics != nil {
		localVarQueryParams.Add("fields[perfPowerMetrics]", parameterToString(*r.fieldsPerfPowerMetrics, "csv"))
	}
	if r.fieldsAppInfos != nil {
		localVarQueryParams.Add("fields[appInfos]", parameterToString(*r.fieldsAppInfos, "csv"))
	}
	if r.fieldsAppPreOrders != nil {
		localVarQueryParams.Add("fields[appPreOrders]", parameterToString(*r.fieldsAppPreOrders, "csv"))
	}
	if r.fieldsPreReleaseVersions != nil {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(*r.fieldsPreReleaseVersions, "csv"))
	}
	if r.fieldsAppPrices != nil {
		localVarQueryParams.Add("fields[appPrices]", parameterToString(*r.fieldsAppPrices, "csv"))
	}
	if r.fieldsInAppPurchases != nil {
		localVarQueryParams.Add("fields[inAppPurchases]", parameterToString(*r.fieldsInAppPurchases, "csv"))
	}
	if r.fieldsBetaAppReviewDetails != nil {
		localVarQueryParams.Add("fields[betaAppReviewDetails]", parameterToString(*r.fieldsBetaAppReviewDetails, "csv"))
	}
	if r.fieldsTerritories != nil {
		localVarQueryParams.Add("fields[territories]", parameterToString(*r.fieldsTerritories, "csv"))
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		localVarQueryParams.Add("fields[gameCenterEnabledVersions]", parameterToString(*r.fieldsGameCenterEnabledVersions, "csv"))
	}
	if r.fieldsAppStoreVersions != nil {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(*r.fieldsAppStoreVersions, "csv"))
	}
	if r.fieldsBuilds != nil {
		localVarQueryParams.Add("fields[builds]", parameterToString(*r.fieldsBuilds, "csv"))
	}
	if r.fieldsBetaAppLocalizations != nil {
		localVarQueryParams.Add("fields[betaAppLocalizations]", parameterToString(*r.fieldsBetaAppLocalizations, "csv"))
	}
	if r.fieldsBetaLicenseAgreements != nil {
		localVarQueryParams.Add("fields[betaLicenseAgreements]", parameterToString(*r.fieldsBetaLicenseAgreements, "csv"))
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		localVarQueryParams.Add("fields[endUserLicenseAgreements]", parameterToString(*r.fieldsEndUserLicenseAgreements, "csv"))
	}
	if r.limitAppInfos != nil {
		localVarQueryParams.Add("limit[appInfos]", parameterToString(*r.limitAppInfos, ""))
	}
	if r.limitAppStoreVersions != nil {
		localVarQueryParams.Add("limit[appStoreVersions]", parameterToString(*r.limitAppStoreVersions, ""))
	}
	if r.limitAvailableTerritories != nil {
		localVarQueryParams.Add("limit[availableTerritories]", parameterToString(*r.limitAvailableTerritories, ""))
	}
	if r.limitBetaAppLocalizations != nil {
		localVarQueryParams.Add("limit[betaAppLocalizations]", parameterToString(*r.limitBetaAppLocalizations, ""))
	}
	if r.limitBetaGroups != nil {
		localVarQueryParams.Add("limit[betaGroups]", parameterToString(*r.limitBetaGroups, ""))
	}
	if r.limitBuilds != nil {
		localVarQueryParams.Add("limit[builds]", parameterToString(*r.limitBuilds, ""))
	}
	if r.limitGameCenterEnabledVersions != nil {
		localVarQueryParams.Add("limit[gameCenterEnabledVersions]", parameterToString(*r.limitGameCenterEnabledVersions, ""))
	}
	if r.limitInAppPurchases != nil {
		localVarQueryParams.Add("limit[inAppPurchases]", parameterToString(*r.limitInAppPurchases, ""))
	}
	if r.limitPreReleaseVersions != nil {
		localVarQueryParams.Add("limit[preReleaseVersions]", parameterToString(*r.limitPreReleaseVersions, ""))
	}
	if r.limitPrices != nil {
		localVarQueryParams.Add("limit[prices]", parameterToString(*r.limitPrices, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGetInstanceRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsApps *[]string
	include *[]string
	fieldsBetaGroups *[]string
	fieldsPerfPowerMetrics *[]string
	fieldsAppInfos *[]string
	fieldsAppPreOrders *[]string
	fieldsPreReleaseVersions *[]string
	fieldsAppPrices *[]string
	fieldsInAppPurchases *[]string
	fieldsBetaAppReviewDetails *[]string
	fieldsTerritories *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsAppStoreVersions *[]string
	fieldsBuilds *[]string
	fieldsBetaAppLocalizations *[]string
	fieldsBetaLicenseAgreements *[]string
	fieldsEndUserLicenseAgreements *[]string
	limitAppInfos *int32
	limitAppStoreVersions *int32
	limitAvailableTerritories *int32
	limitBetaAppLocalizations *int32
	limitBetaGroups *int32
	limitBuilds *int32
	limitGameCenterEnabledVersions *int32
	limitInAppPurchases *int32
	limitPreReleaseVersions *int32
	limitPrices *int32
}

func (r ApiAppsGetInstanceRequest) FieldsApps(fieldsApps []string) ApiAppsGetInstanceRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsGetInstanceRequest) Include(include []string) ApiAppsGetInstanceRequest {
	r.include = &include
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsPerfPowerMetrics(fieldsPerfPowerMetrics []string) ApiAppsGetInstanceRequest {
	r.fieldsPerfPowerMetrics = &fieldsPerfPowerMetrics
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsGetInstanceRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}
func (r ApiAppsGetInstanceRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsGetInstanceRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}
func (r ApiAppsGetInstanceRequest) LimitAppInfos(limitAppInfos int32) ApiAppsGetInstanceRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}
func (r ApiAppsGetInstanceRequest) LimitAppStoreVersions(limitAppStoreVersions int32) ApiAppsGetInstanceRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}
func (r ApiAppsGetInstanceRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiAppsGetInstanceRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}
func (r ApiAppsGetInstanceRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) ApiAppsGetInstanceRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}
func (r ApiAppsGetInstanceRequest) LimitBetaGroups(limitBetaGroups int32) ApiAppsGetInstanceRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}
func (r ApiAppsGetInstanceRequest) LimitBuilds(limitBuilds int32) ApiAppsGetInstanceRequest {
	r.limitBuilds = &limitBuilds
	return r
}
func (r ApiAppsGetInstanceRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) ApiAppsGetInstanceRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}
func (r ApiAppsGetInstanceRequest) LimitInAppPurchases(limitInAppPurchases int32) ApiAppsGetInstanceRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}
func (r ApiAppsGetInstanceRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) ApiAppsGetInstanceRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}
func (r ApiAppsGetInstanceRequest) LimitPrices(limitPrices int32) ApiAppsGetInstanceRequest {
	r.limitPrices = &limitPrices
	return r
}

func (r ApiAppsGetInstanceRequest) Execute() (AppResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsGetInstanceExecute(r)
}

/*
 * AppsGetInstance Method for AppsGetInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsGetInstanceRequest
 */
func (a *AppsApiService) AppsGetInstance(ctx _context.Context, id string) ApiAppsGetInstanceRequest {
	return ApiAppsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppResponse
 */
func (a *AppsApiService) AppsGetInstanceExecute(r ApiAppsGetInstanceRequest) (AppResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsBetaGroups != nil {
		localVarQueryParams.Add("fields[betaGroups]", parameterToString(*r.fieldsBetaGroups, "csv"))
	}
	if r.fieldsPerfPowerMetrics != nil {
		localVarQueryParams.Add("fields[perfPowerMetrics]", parameterToString(*r.fieldsPerfPowerMetrics, "csv"))
	}
	if r.fieldsAppInfos != nil {
		localVarQueryParams.Add("fields[appInfos]", parameterToString(*r.fieldsAppInfos, "csv"))
	}
	if r.fieldsAppPreOrders != nil {
		localVarQueryParams.Add("fields[appPreOrders]", parameterToString(*r.fieldsAppPreOrders, "csv"))
	}
	if r.fieldsPreReleaseVersions != nil {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(*r.fieldsPreReleaseVersions, "csv"))
	}
	if r.fieldsAppPrices != nil {
		localVarQueryParams.Add("fields[appPrices]", parameterToString(*r.fieldsAppPrices, "csv"))
	}
	if r.fieldsInAppPurchases != nil {
		localVarQueryParams.Add("fields[inAppPurchases]", parameterToString(*r.fieldsInAppPurchases, "csv"))
	}
	if r.fieldsBetaAppReviewDetails != nil {
		localVarQueryParams.Add("fields[betaAppReviewDetails]", parameterToString(*r.fieldsBetaAppReviewDetails, "csv"))
	}
	if r.fieldsTerritories != nil {
		localVarQueryParams.Add("fields[territories]", parameterToString(*r.fieldsTerritories, "csv"))
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		localVarQueryParams.Add("fields[gameCenterEnabledVersions]", parameterToString(*r.fieldsGameCenterEnabledVersions, "csv"))
	}
	if r.fieldsAppStoreVersions != nil {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(*r.fieldsAppStoreVersions, "csv"))
	}
	if r.fieldsBuilds != nil {
		localVarQueryParams.Add("fields[builds]", parameterToString(*r.fieldsBuilds, "csv"))
	}
	if r.fieldsBetaAppLocalizations != nil {
		localVarQueryParams.Add("fields[betaAppLocalizations]", parameterToString(*r.fieldsBetaAppLocalizations, "csv"))
	}
	if r.fieldsBetaLicenseAgreements != nil {
		localVarQueryParams.Add("fields[betaLicenseAgreements]", parameterToString(*r.fieldsBetaLicenseAgreements, "csv"))
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		localVarQueryParams.Add("fields[endUserLicenseAgreements]", parameterToString(*r.fieldsEndUserLicenseAgreements, "csv"))
	}
	if r.limitAppInfos != nil {
		localVarQueryParams.Add("limit[appInfos]", parameterToString(*r.limitAppInfos, ""))
	}
	if r.limitAppStoreVersions != nil {
		localVarQueryParams.Add("limit[appStoreVersions]", parameterToString(*r.limitAppStoreVersions, ""))
	}
	if r.limitAvailableTerritories != nil {
		localVarQueryParams.Add("limit[availableTerritories]", parameterToString(*r.limitAvailableTerritories, ""))
	}
	if r.limitBetaAppLocalizations != nil {
		localVarQueryParams.Add("limit[betaAppLocalizations]", parameterToString(*r.limitBetaAppLocalizations, ""))
	}
	if r.limitBetaGroups != nil {
		localVarQueryParams.Add("limit[betaGroups]", parameterToString(*r.limitBetaGroups, ""))
	}
	if r.limitBuilds != nil {
		localVarQueryParams.Add("limit[builds]", parameterToString(*r.limitBuilds, ""))
	}
	if r.limitGameCenterEnabledVersions != nil {
		localVarQueryParams.Add("limit[gameCenterEnabledVersions]", parameterToString(*r.limitGameCenterEnabledVersions, ""))
	}
	if r.limitInAppPurchases != nil {
		localVarQueryParams.Add("limit[inAppPurchases]", parameterToString(*r.limitInAppPurchases, ""))
	}
	if r.limitPreReleaseVersions != nil {
		localVarQueryParams.Add("limit[preReleaseVersions]", parameterToString(*r.limitPreReleaseVersions, ""))
	}
	if r.limitPrices != nil {
		localVarQueryParams.Add("limit[prices]", parameterToString(*r.limitPrices, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsInAppPurchasesGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	filterInAppPurchaseType *[]string
	filterCanBeSubmitted *[]string
	sort *[]string
	fieldsInAppPurchases *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
}

func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FilterCanBeSubmitted(filterCanBeSubmitted []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterCanBeSubmitted = &filterCanBeSubmitted
	return r
}
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Sort(sort []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.sort = &sort
	return r
}
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Limit(limit int32) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Include(include []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Execute() (InAppPurchasesResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsInAppPurchasesGetToManyRelatedExecute(r)
}

/*
 * AppsInAppPurchasesGetToManyRelated Method for AppsInAppPurchasesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsInAppPurchasesGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelated(ctx _context.Context, id string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	return ApiAppsInAppPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InAppPurchasesResponse
 */
func (a *AppsApiService) AppsInAppPurchasesGetToManyRelatedExecute(r ApiAppsInAppPurchasesGetToManyRelatedRequest) (InAppPurchasesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InAppPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsInAppPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterInAppPurchaseType != nil {
		localVarQueryParams.Add("filter[inAppPurchaseType]", parameterToString(*r.filterInAppPurchaseType, "csv"))
	}
	if r.filterCanBeSubmitted != nil {
		localVarQueryParams.Add("filter[canBeSubmitted]", parameterToString(*r.filterCanBeSubmitted, "csv"))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, "csv"))
	}
	if r.fieldsInAppPurchases != nil {
		localVarQueryParams.Add("fields[inAppPurchases]", parameterToString(*r.fieldsInAppPurchases, "csv"))
	}
	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPerfPowerMetricsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	filterDeviceType *[]string
	filterMetricType *[]string
	filterPlatform *[]string
}

func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterDeviceType(filterDeviceType []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterDeviceType = &filterDeviceType
	return r
}
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterMetricType(filterMetricType []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterMetricType = &filterMetricType
	return r
}
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) Execute() (PerfPowerMetricsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsPerfPowerMetricsGetToManyRelatedExecute(r)
}

/*
 * AppsPerfPowerMetricsGetToManyRelated Method for AppsPerfPowerMetricsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsPerfPowerMetricsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelated(ctx _context.Context, id string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	return ApiAppsPerfPowerMetricsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return PerfPowerMetricsResponse
 */
func (a *AppsApiService) AppsPerfPowerMetricsGetToManyRelatedExecute(r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) (PerfPowerMetricsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PerfPowerMetricsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPerfPowerMetricsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/perfPowerMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterDeviceType != nil {
		localVarQueryParams.Add("filter[deviceType]", parameterToString(*r.filterDeviceType, "csv"))
	}
	if r.filterMetricType != nil {
		localVarQueryParams.Add("filter[metricType]", parameterToString(*r.filterMetricType, "csv"))
	}
	if r.filterPlatform != nil {
		localVarQueryParams.Add("filter[platform]", parameterToString(*r.filterPlatform, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPreOrderGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsAppPreOrders *[]string
}

func (r ApiAppsPreOrderGetToOneRelatedRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsPreOrderGetToOneRelatedRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

func (r ApiAppsPreOrderGetToOneRelatedRequest) Execute() (AppPreOrderResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsPreOrderGetToOneRelatedExecute(r)
}

/*
 * AppsPreOrderGetToOneRelated Method for AppsPreOrderGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsPreOrderGetToOneRelatedRequest
 */
func (a *AppsApiService) AppsPreOrderGetToOneRelated(ctx _context.Context, id string) ApiAppsPreOrderGetToOneRelatedRequest {
	return ApiAppsPreOrderGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppPreOrderResponse
 */
func (a *AppsApiService) AppsPreOrderGetToOneRelatedExecute(r ApiAppsPreOrderGetToOneRelatedRequest) (AppPreOrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppPreOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPreOrderGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppPreOrders != nil {
		localVarQueryParams.Add("fields[appPreOrders]", parameterToString(*r.fieldsAppPreOrders, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPreReleaseVersionsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsPreReleaseVersions *[]string
	limit *int32
}

func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}
func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) Execute() (PreReleaseVersionsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsPreReleaseVersionsGetToManyRelatedExecute(r)
}

/*
 * AppsPreReleaseVersionsGetToManyRelated Method for AppsPreReleaseVersionsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsPreReleaseVersionsGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelated(ctx _context.Context, id string) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	return ApiAppsPreReleaseVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return PreReleaseVersionsResponse
 */
func (a *AppsApiService) AppsPreReleaseVersionsGetToManyRelatedExecute(r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) (PreReleaseVersionsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PreReleaseVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPreReleaseVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preReleaseVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsPreReleaseVersions != nil {
		localVarQueryParams.Add("fields[preReleaseVersions]", parameterToString(*r.fieldsPreReleaseVersions, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPricesGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	fieldsAppPrices *[]string
	fieldsAppPriceTiers *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
}

func (r ApiAppsPricesGetToManyRelatedRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsPricesGetToManyRelatedRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}
func (r ApiAppsPricesGetToManyRelatedRequest) FieldsAppPriceTiers(fieldsAppPriceTiers []string) ApiAppsPricesGetToManyRelatedRequest {
	r.fieldsAppPriceTiers = &fieldsAppPriceTiers
	return r
}
func (r ApiAppsPricesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsPricesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}
func (r ApiAppsPricesGetToManyRelatedRequest) Limit(limit int32) ApiAppsPricesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}
func (r ApiAppsPricesGetToManyRelatedRequest) Include(include []string) ApiAppsPricesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsPricesGetToManyRelatedRequest) Execute() (AppPricesResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsPricesGetToManyRelatedExecute(r)
}

/*
 * AppsPricesGetToManyRelated Method for AppsPricesGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsPricesGetToManyRelatedRequest
 */
func (a *AppsApiService) AppsPricesGetToManyRelated(ctx _context.Context, id string) ApiAppsPricesGetToManyRelatedRequest {
	return ApiAppsPricesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppPricesResponse
 */
func (a *AppsApiService) AppsPricesGetToManyRelatedExecute(r ApiAppsPricesGetToManyRelatedRequest) (AppPricesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppPricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsPricesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppPrices != nil {
		localVarQueryParams.Add("fields[appPrices]", parameterToString(*r.fieldsAppPrices, "csv"))
	}
	if r.fieldsAppPriceTiers != nil {
		localVarQueryParams.Add("fields[appPriceTiers]", parameterToString(*r.fieldsAppPriceTiers, "csv"))
	}
	if r.fieldsApps != nil {
		localVarQueryParams.Add("fields[apps]", parameterToString(*r.fieldsApps, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsUpdateInstanceRequest struct {
	ctx _context.Context
	ApiService *AppsApiService
	id string
	appUpdateRequest *AppUpdateRequest
}

func (r ApiAppsUpdateInstanceRequest) AppUpdateRequest(appUpdateRequest AppUpdateRequest) ApiAppsUpdateInstanceRequest {
	r.appUpdateRequest = &appUpdateRequest
	return r
}

func (r ApiAppsUpdateInstanceRequest) Execute() (AppResponse, *_nethttp.Response, error) {
	return r.ApiService.AppsUpdateInstanceExecute(r)
}

/*
 * AppsUpdateInstance Method for AppsUpdateInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppsUpdateInstanceRequest
 */
func (a *AppsApiService) AppsUpdateInstance(ctx _context.Context, id string) ApiAppsUpdateInstanceRequest {
	return ApiAppsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppResponse
 */
func (a *AppsApiService) AppsUpdateInstanceExecute(r ApiAppsUpdateInstanceRequest) (AppResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsApiService.AppsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
