/*
 * App Store Connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.2
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AppStoreVersionsApiService AppStoreVersionsApi service
type AppStoreVersionsApiService service

type ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsAgeRatingDeclarations *[]string
}

func (r ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

func (r ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest) Execute() (AgeRatingDeclarationResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsAgeRatingDeclarationGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsAgeRatingDeclarationGetToOneRelated Method for AppStoreVersionsAgeRatingDeclarationGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest {
	return ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AgeRatingDeclarationResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAgeRatingDeclarationGetToOneRelatedExecute(r ApiAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest) (AgeRatingDeclarationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AgeRatingDeclarationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsAgeRatingDeclarationGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/ageRatingDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAgeRatingDeclarations != nil {
		localVarQueryParams.Add("fields[ageRatingDeclarations]", parameterToString(*r.fieldsAgeRatingDeclarations, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsAppStoreReviewDetails *[]string
	fieldsAppStoreVersions *[]string
	fieldsAppStoreReviewAttachments *[]string
	include *[]string
}

func (r ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}
func (r ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}
func (r ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest) FieldsAppStoreReviewAttachments(fieldsAppStoreReviewAttachments []string) ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest {
	r.fieldsAppStoreReviewAttachments = &fieldsAppStoreReviewAttachments
	return r
}
func (r ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest) Include(include []string) ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest) Execute() (AppStoreReviewDetailResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsAppStoreReviewDetailGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsAppStoreReviewDetailGetToOneRelated Method for AppStoreVersionsAppStoreReviewDetailGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest {
	return ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreReviewDetailResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreReviewDetailGetToOneRelatedExecute(r ApiAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest) (AppStoreReviewDetailResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreReviewDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsAppStoreReviewDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/appStoreReviewDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppStoreReviewDetails != nil {
		localVarQueryParams.Add("fields[appStoreReviewDetails]", parameterToString(*r.fieldsAppStoreReviewDetails, "csv"))
	}
	if r.fieldsAppStoreVersions != nil {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(*r.fieldsAppStoreVersions, "csv"))
	}
	if r.fieldsAppStoreReviewAttachments != nil {
		localVarQueryParams.Add("fields[appStoreReviewAttachments]", parameterToString(*r.fieldsAppStoreReviewAttachments, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsAppStoreVersionLocalizations *[]string
	limit *int32
}

func (r ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}
func (r ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest) Execute() (AppStoreVersionLocalizationsResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedExecute(r)
}

/*
 * AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated Method for AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx _context.Context, id string) ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest {
	return ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionLocalizationsResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedExecute(r ApiAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest) (AppStoreVersionLocalizationsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/appStoreVersionLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppStoreVersionLocalizations != nil {
		localVarQueryParams.Add("fields[appStoreVersionLocalizations]", parameterToString(*r.fieldsAppStoreVersionLocalizations, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsAppStoreVersionPhasedReleases *[]string
}

func (r ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}

func (r ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest) Execute() (AppStoreVersionPhasedReleaseResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated Method for AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest {
	return ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionPhasedReleaseResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedExecute(r ApiAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest) (AppStoreVersionPhasedReleaseResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionPhasedReleaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/appStoreVersionPhasedRelease"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppStoreVersionPhasedReleases != nil {
		localVarQueryParams.Add("fields[appStoreVersionPhasedReleases]", parameterToString(*r.fieldsAppStoreVersionPhasedReleases, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsAppStoreVersions *[]string
	fieldsAppStoreVersionSubmissions *[]string
	include *[]string
}

func (r ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}
func (r ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}
func (r ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest) Include(include []string) ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest) Execute() (AppStoreVersionSubmissionResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated Method for AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest {
	return ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionSubmissionResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedExecute(r ApiAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest) (AppStoreVersionSubmissionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionSubmissionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/appStoreVersionSubmission"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppStoreVersions != nil {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(*r.fieldsAppStoreVersions, "csv"))
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		localVarQueryParams.Add("fields[appStoreVersionSubmissions]", parameterToString(*r.fieldsAppStoreVersionSubmissions, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsBuildGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsBuilds *[]string
}

func (r ApiAppStoreVersionsBuildGetToOneRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppStoreVersionsBuildGetToOneRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

func (r ApiAppStoreVersionsBuildGetToOneRelatedRequest) Execute() (BuildResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsBuildGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsBuildGetToOneRelated Method for AppStoreVersionsBuildGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsBuildGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsBuildGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsBuildGetToOneRelatedRequest {
	return ApiAppStoreVersionsBuildGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BuildResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsBuildGetToOneRelatedExecute(r ApiAppStoreVersionsBuildGetToOneRelatedRequest) (BuildResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BuildResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsBuildGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/build"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsBuilds != nil {
		localVarQueryParams.Add("fields[builds]", parameterToString(*r.fieldsBuilds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsBuildGetToOneRelationshipRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
}


func (r ApiAppStoreVersionsBuildGetToOneRelationshipRequest) Execute() (AppStoreVersionBuildLinkageResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsBuildGetToOneRelationshipExecute(r)
}

/*
 * AppStoreVersionsBuildGetToOneRelationship Method for AppStoreVersionsBuildGetToOneRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsBuildGetToOneRelationshipRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsBuildGetToOneRelationship(ctx _context.Context, id string) ApiAppStoreVersionsBuildGetToOneRelationshipRequest {
	return ApiAppStoreVersionsBuildGetToOneRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionBuildLinkageResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsBuildGetToOneRelationshipExecute(r ApiAppStoreVersionsBuildGetToOneRelationshipRequest) (AppStoreVersionBuildLinkageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionBuildLinkageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsBuildGetToOneRelationship")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/relationships/build"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	appStoreVersionBuildLinkageRequest *AppStoreVersionBuildLinkageRequest
}

func (r ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest) AppStoreVersionBuildLinkageRequest(appStoreVersionBuildLinkageRequest AppStoreVersionBuildLinkageRequest) ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest {
	r.appStoreVersionBuildLinkageRequest = &appStoreVersionBuildLinkageRequest
	return r
}

func (r ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsBuildUpdateToOneRelationshipExecute(r)
}

/*
 * AppStoreVersionsBuildUpdateToOneRelationship Method for AppStoreVersionsBuildUpdateToOneRelationship
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsBuildUpdateToOneRelationship(ctx _context.Context, id string) ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest {
	return ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsBuildUpdateToOneRelationshipExecute(r ApiAppStoreVersionsBuildUpdateToOneRelationshipRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsBuildUpdateToOneRelationship")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/relationships/build"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appStoreVersionBuildLinkageRequest == nil {
		return nil, reportError("appStoreVersionBuildLinkageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appStoreVersionBuildLinkageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppStoreVersionsCreateInstanceRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	appStoreVersionCreateRequest *AppStoreVersionCreateRequest
}

func (r ApiAppStoreVersionsCreateInstanceRequest) AppStoreVersionCreateRequest(appStoreVersionCreateRequest AppStoreVersionCreateRequest) ApiAppStoreVersionsCreateInstanceRequest {
	r.appStoreVersionCreateRequest = &appStoreVersionCreateRequest
	return r
}

func (r ApiAppStoreVersionsCreateInstanceRequest) Execute() (AppStoreVersionResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsCreateInstanceExecute(r)
}

/*
 * AppStoreVersionsCreateInstance Method for AppStoreVersionsCreateInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAppStoreVersionsCreateInstanceRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsCreateInstance(ctx _context.Context) ApiAppStoreVersionsCreateInstanceRequest {
	return ApiAppStoreVersionsCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsCreateInstanceExecute(r ApiAppStoreVersionsCreateInstanceRequest) (AppStoreVersionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appStoreVersionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("appStoreVersionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appStoreVersionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsDeleteInstanceRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
}


func (r ApiAppStoreVersionsDeleteInstanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsDeleteInstanceExecute(r)
}

/*
 * AppStoreVersionsDeleteInstance Method for AppStoreVersionsDeleteInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsDeleteInstanceRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsDeleteInstance(ctx _context.Context, id string) ApiAppStoreVersionsDeleteInstanceRequest {
	return ApiAppStoreVersionsDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsDeleteInstanceExecute(r ApiAppStoreVersionsDeleteInstanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsDeleteInstance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppStoreVersionsGetInstanceRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsAppStoreVersions *[]string
	include *[]string
	fieldsAppStoreVersionLocalizations *[]string
	fieldsIdfaDeclarations *[]string
	fieldsRoutingAppCoverages *[]string
	fieldsAppStoreVersionPhasedReleases *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppStoreReviewDetails *[]string
	fieldsBuilds *[]string
	fieldsAppStoreVersionSubmissions *[]string
	limitAppStoreVersionLocalizations *int32
}

func (r ApiAppStoreVersionsGetInstanceRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) Include(include []string) ApiAppStoreVersionsGetInstanceRequest {
	r.include = &include
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsIdfaDeclarations(fieldsIdfaDeclarations []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsIdfaDeclarations = &fieldsIdfaDeclarations
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) ApiAppStoreVersionsGetInstanceRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}
func (r ApiAppStoreVersionsGetInstanceRequest) LimitAppStoreVersionLocalizations(limitAppStoreVersionLocalizations int32) ApiAppStoreVersionsGetInstanceRequest {
	r.limitAppStoreVersionLocalizations = &limitAppStoreVersionLocalizations
	return r
}

func (r ApiAppStoreVersionsGetInstanceRequest) Execute() (AppStoreVersionResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsGetInstanceExecute(r)
}

/*
 * AppStoreVersionsGetInstance Method for AppStoreVersionsGetInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsGetInstanceRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsGetInstance(ctx _context.Context, id string) ApiAppStoreVersionsGetInstanceRequest {
	return ApiAppStoreVersionsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsGetInstanceExecute(r ApiAppStoreVersionsGetInstanceRequest) (AppStoreVersionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsAppStoreVersions != nil {
		localVarQueryParams.Add("fields[appStoreVersions]", parameterToString(*r.fieldsAppStoreVersions, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsAppStoreVersionLocalizations != nil {
		localVarQueryParams.Add("fields[appStoreVersionLocalizations]", parameterToString(*r.fieldsAppStoreVersionLocalizations, "csv"))
	}
	if r.fieldsIdfaDeclarations != nil {
		localVarQueryParams.Add("fields[idfaDeclarations]", parameterToString(*r.fieldsIdfaDeclarations, "csv"))
	}
	if r.fieldsRoutingAppCoverages != nil {
		localVarQueryParams.Add("fields[routingAppCoverages]", parameterToString(*r.fieldsRoutingAppCoverages, "csv"))
	}
	if r.fieldsAppStoreVersionPhasedReleases != nil {
		localVarQueryParams.Add("fields[appStoreVersionPhasedReleases]", parameterToString(*r.fieldsAppStoreVersionPhasedReleases, "csv"))
	}
	if r.fieldsAgeRatingDeclarations != nil {
		localVarQueryParams.Add("fields[ageRatingDeclarations]", parameterToString(*r.fieldsAgeRatingDeclarations, "csv"))
	}
	if r.fieldsAppStoreReviewDetails != nil {
		localVarQueryParams.Add("fields[appStoreReviewDetails]", parameterToString(*r.fieldsAppStoreReviewDetails, "csv"))
	}
	if r.fieldsBuilds != nil {
		localVarQueryParams.Add("fields[builds]", parameterToString(*r.fieldsBuilds, "csv"))
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		localVarQueryParams.Add("fields[appStoreVersionSubmissions]", parameterToString(*r.fieldsAppStoreVersionSubmissions, "csv"))
	}
	if r.limitAppStoreVersionLocalizations != nil {
		localVarQueryParams.Add("limit[appStoreVersionLocalizations]", parameterToString(*r.limitAppStoreVersionLocalizations, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsIdfaDeclarations *[]string
}

func (r ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest) FieldsIdfaDeclarations(fieldsIdfaDeclarations []string) ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest {
	r.fieldsIdfaDeclarations = &fieldsIdfaDeclarations
	return r
}

func (r ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest) Execute() (IdfaDeclarationResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsIdfaDeclarationGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsIdfaDeclarationGetToOneRelated Method for AppStoreVersionsIdfaDeclarationGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest {
	return ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return IdfaDeclarationResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsIdfaDeclarationGetToOneRelatedExecute(r ApiAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest) (IdfaDeclarationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IdfaDeclarationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsIdfaDeclarationGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/idfaDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsIdfaDeclarations != nil {
		localVarQueryParams.Add("fields[idfaDeclarations]", parameterToString(*r.fieldsIdfaDeclarations, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	fieldsRoutingAppCoverages *[]string
}

func (r ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}

func (r ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest) Execute() (RoutingAppCoverageResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsRoutingAppCoverageGetToOneRelatedExecute(r)
}

/*
 * AppStoreVersionsRoutingAppCoverageGetToOneRelated Method for AppStoreVersionsRoutingAppCoverageGetToOneRelated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx _context.Context, id string) ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest {
	return ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return RoutingAppCoverageResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsRoutingAppCoverageGetToOneRelatedExecute(r ApiAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest) (RoutingAppCoverageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RoutingAppCoverageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsRoutingAppCoverageGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}/routingAppCoverage"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fieldsRoutingAppCoverages != nil {
		localVarQueryParams.Add("fields[routingAppCoverages]", parameterToString(*r.fieldsRoutingAppCoverages, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppStoreVersionsUpdateInstanceRequest struct {
	ctx _context.Context
	ApiService *AppStoreVersionsApiService
	id string
	appStoreVersionUpdateRequest *AppStoreVersionUpdateRequest
}

func (r ApiAppStoreVersionsUpdateInstanceRequest) AppStoreVersionUpdateRequest(appStoreVersionUpdateRequest AppStoreVersionUpdateRequest) ApiAppStoreVersionsUpdateInstanceRequest {
	r.appStoreVersionUpdateRequest = &appStoreVersionUpdateRequest
	return r
}

func (r ApiAppStoreVersionsUpdateInstanceRequest) Execute() (AppStoreVersionResponse, *_nethttp.Response, error) {
	return r.ApiService.AppStoreVersionsUpdateInstanceExecute(r)
}

/*
 * AppStoreVersionsUpdateInstance Method for AppStoreVersionsUpdateInstance
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id the id of the requested resource
 * @return ApiAppStoreVersionsUpdateInstanceRequest
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsUpdateInstance(ctx _context.Context, id string) ApiAppStoreVersionsUpdateInstanceRequest {
	return ApiAppStoreVersionsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AppStoreVersionResponse
 */
func (a *AppStoreVersionsApiService) AppStoreVersionsUpdateInstanceExecute(r ApiAppStoreVersionsUpdateInstanceRequest) (AppStoreVersionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AppStoreVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppStoreVersionsApiService.AppStoreVersionsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appStoreVersions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.appStoreVersionUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appStoreVersionUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appStoreVersionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
